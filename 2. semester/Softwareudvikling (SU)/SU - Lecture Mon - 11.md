---
date: 13-03-23
day: Mon
week: 11
year: 2023
type: Lecture
course: SU
status: 
semester: 2
tags: SOLID, Designpatterns
Summary: "SOLID principles and design patterns"
---
##### Weekly note
[[Uge 11 - 2023]]

# Mediator pattern
A mediator promotes the loose coupling of objects by avoiding an explicit relationship between the involved objects

The distribution of the behavior to many objects is usually the basis for the good changeability and reusability of object-oriented systems

**But** Too many relationships between too many objects reduce the changeability and reusability because building such object structures is complex.

An object operates as an intermediary between the other objects

Communication between all involved objects always takes place via the intermediary.

Further objects can be connected very easily.
![[Pasted image 20230313090053.png]]
![[Pasted image 20230313090119.png]]
### General structure of a mediator pattern: class diagram
![[Pasted image 20230313090201.png|300]]
## Summary Mediator pattern
### Advantages:
- The mediator pattern simplifies the protocol between objects: All partner objects call only the methods of the mediator. 
- The mediator pattern abstracts from the collaboration between the objects: All partner objects know only the mediator. 
- The mediator pattern decouples the objects of the system: Further objects as well as further partner classes can be easily integrate
### Disadvantages:
The mediator fulfills a central task: The complexity of the interaction is replaced by the complexity of the mediator

### Remarks: 
**Comparison with the facade pattern:** 
- A facade provides a more convenient interface to simplify the use. 
- A facade supports a unidirectional protocol between classes. 
- A mediator supports multidirectional protocol to simplify the collaboration of objects
# Singleton pattern
ensures that there is only one single object from a class.
### Motivation
There are classes, of which only one object can exist at runtime. 

Example: 
Assigning unique keys, such as order numbers, customer numbers, ..

The class itself ensures that there is only one object: 
- The implementation depends on the possibilities of the programming language. 
- Access to constructors must be restricted, (e.g. by preventing access: The constructors are agreed privately! 
- Instead of the constructor, special static methods control the creation of only one object
## Implementation
![[Pasted image 20230313091459.png|400]]
![[Pasted image 20230313091619.png|400]]
![[Pasted image 20230313091644.png|400]]
![[Pasted image 20230313091720.png|400]]
# Abstract factory pattern
allows the use of the same procedures for different families of objects

A software product can be used with the largely identical processes in different contexts. The same parts should be maintained unchanged

The software consists of a constant application core and other components, which occur in different variants. 
- Only components that match, that is, belong to a family of products, are selected for a configuration. 
- The components required for a configuration are generated by a special component, the factory, as needed.
![[Pasted image 20230313091842.png|300]]
General structure (objects of application)
![[Pasted image 20230313091920.png|200]]
![[Pasted image 20230313092023.png|300]]
![[Pasted image 20230313092057.png|300]]
![[Pasted image 20230313092120.png|400]]
## Summary of the factory pattern
### Advantages: 
- The Abstract factory pattern simplifies the customization of a software product by exchanging groups (families) of objects. 
- The adjustment is made dynamically at runtime. 
- Further product families can easily be added in the framework given by the interfaces

### Disadvantages: 
- The pre-recognition of a situation which is sustainably supported by an abstract factory is difficult. 
- The construction of an abstract factory is complex. In particular, a suitable description of the scope of the product family must be carried out as preparation. 
- The creation of an abstract factory is only profitable if actually several products can be identified in different families
# Summary  - Design patterns
All design patterns have been derived from experience. 
	• Design patterns provide appropriate solutions for recurring problems. 
	• Some design patterns are supported in standard libraries. 
	• Design patterns can be flexibly implemented in various ways. 
	• Design patterns provide a common vocabulary for developers. 
	• Design patterns can be combined with each other Example: Observer iterates over the observed objects.
![[Pasted image 20230313092350.png]]
# SOLID principles
What are reasons for unsuccessful applications? 
	• Putting more functionalities on classes 
	• Implementing tight coupling between software components (i.e., between classes). If classes are dependent on each other, then change in one class will affect other classes also 

How to overcome these problems? 
	• Need to use correct design 
	• Need to follow design principles (i.e., SOLID Principles, GRASP Principles) 
	• Need to choose correct design patterns

The principles, when applied together, intend to make easy to maintain and extend over time system
## S – SRP - Single responsibility principle
Every class, function, variable should define a single responsibility, and that responsibility should be entirely encapsulated by the context

It is important to keep a class focused on a single concern is that it makes the class more robust

“There should never be more than one reason for a class to change.”

Each responsibility should be a separate class, because each responsibility is an axis of change. A class should have one, and only one, reason to change. If a change to the business rules causes a class to change, then a change to the database schema, GUI, report format, or any other segment of the system should not force that class to change.

Think of an car assembly line where each robot have been streamlined for one task.

• Axis of Change
• Separation of Concern
• Test-Driven Development
• Logical Separation of Namespaces And Assemblies
## O –OCP - Open/closed principle 
Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification that is, such an entity can allow its behavior to be extended without modifying its source code

This is especially valuable in a production environment, where changes to source code may necessitate code reviews, unit tests, and other such procedures to qualify it for use in a product

software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.”

You can easily change the lens of most SLR cameras without having to saw off the old lens and weld on a new one


Meyer's Open/Closed Principle 
	• Implementation of a class should only be modified to correct errors. 
	• Changes or new features require that a different class be created (Interfaces)
Polymorphic Open/Closed Principle 
	• All member variables should be private. 
	• Global variables should be avoided

## L – LSP - Liskov substitution principle
It is a particular definition of a subtyping relation, called behavioral subtyping

If S is a subtype of T, then objects of type T may be replaced with objects of type S *without altering* any of the desirable properties of that program

“Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program” 

“Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.”

- Polymorphism
- Test-Driven Development (TDD)
- Avoid Run-Time Type Information (RTTI)
### Objects should be replaceable with subtypes
When overriding a class you must be carful that the way you extend it does not cause it to no longer work in place of the class it inherited from
![[Pasted image 20230313093107.png|400]]
## I – ISP - Interface segregation principle
It states that no client should be forced to depend on methods it does not use

ISP splits interfaces which are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them

“Many client specific interfaces are better than one general purpose interface” 

“Clients should not be forced to depend upon interfaces that they do not use.”

- Design by contract (DbC) / Design to Interfaces 
- Test-Driven Development (TDD)

Many specific interfaces are better than one general

Clients should not depend upon interfaces that they do not use
![[Pasted image 20230313093256.png|300]]
Each interface should specifically describe only what is needed and nothing more
## D – DIP - Dependency inversion principle
High-level modules should not depend on low-level modules: both should depend on abstractions.

Abstractions should not depend on details. Details should depend on abstractions.

“High level modules should not depend upon low level modules. both should depend upon abstractions.” 

“Abstractions should not depend upon details. Details should depend upon abstractions.”

- Loose Coupling
- Dependency Injection / Inversion of Control
### Dependency Injection / Inversion of Control
![[Pasted image 20230313093422.png]]

High & low level modules should depend upon abstractions

No reference or dependency to a specific Data access technology should ever exist outside of the Data Access Assembly this includes ADO.net, LinqToSql, EF4, Nhibernate... 

Only Interfaces and POCO (Plain Old CLR Objects) should be referenced between assemblies and primarily they should reference an interface.
## SOLID BAD SMELLS
![[Pasted image 20230313093520.png|350]]
## A SOLID Summary
### SRP: 
There should never be more than one reason for a class to change
### OCP: 
Software entities should be open for extension but closed for modification
### LSP: 
Functions that use references to base classes must be able to use objects of derived classes without knowing it.
### ISP: 
Clients should not be forced to depend upon interfaces that they do not use .
### DIP: 
• High level modules should not depend upon low level modules. Both should depend upon abstractions. 
• Abstractions should not depend upon details. Details should depend upon abstractions

# GRASP Pattern
**G**eneral **R**esponsibility **A**ssignment **S**oftware **P**atterns

Assigning *responsibilities* to classes is critical aspect of object-oriented design.

*Appropriate* assignment of responsibilities to classes is key to successful design.

There are *fundamental principles* in assigning responsibilities that experienced designers apply.

These principles are summarized in GRASP patterns.

Has nine core principles that object-oriented designers apply when assigning responsibilities to classes and designing message interactions:

**Information Expert (cf. information hiding)** 
	• determines where to delegate responsibilities, e.g., methods and computation 
**Creator** 
	• determines responsibility for object creation • 
**Controller** 
	• non-user interface object responsible for receiving or handling system events  
**Low Coupling (cf. Code Complexity lecture B4-03)** 
	• measures of how strongly one element is dependent on other element
**High Cohesion (cf. Code Complexity lecture B4-03)** 
	• responsibilities of given set of elements are strongly related and highly focused on rather specific topic
**Polymorphism** 
	• defining variation of behaviors based on type is assigned to the type for which this variation happens 
**Pure Fabrication** 
	• Entity is service and does not represent concept in problem domain
**Indirection** 
	• assigns responsibility of mediation between them to intermediate object instead of direct connection (man-in-themiddle) 
**Protected variations** 
	• protects elements from variations on other elements by wrapping focus of instability with interface and using polymorphism (cf. OCP)
# Summary – Design patterns
Design patterns are ideas for solutions but no finished solutions. 

Design patterns must be adapted to the specific problem. 

The use of design patterns requires experience in the design of object-oriented software. 

Design patterns usually comprise only a few classes, many design patterns are obvious object-oriented solutions. 

Design patterns are difficult to recognize in source code. 
It is even more difficult to recognize combinations of design patterns in the source text. 

A senseless use of design patterns does not make software any better
